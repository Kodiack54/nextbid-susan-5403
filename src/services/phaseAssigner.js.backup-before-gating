/**
 * Susan Phase Assigner
 * Assigns bugs/todos to the correct phase based on keywords
 * Matches item titles against phase item keywords
 */

const { from } = require('../lib/db');
const { Logger } = require('../lib/logger');

const logger = new Logger('Susan:PhaseAssigner');

/**
 * Extract search terms from text
 */
function extractTerms(text) {
  if (!text) return [];
  const stopWords = ['the','a','an','in','on','at','to','for','of','and','or','is','are','with','from','more','new'];
  return text.toLowerCase()
    .replace(/[^a-z0-9\s]/g, '')
    .split(/\s+/)
    .filter(w => w.length > 2 && !stopWords.includes(w));
}

/**
 * Get all phases and phase items for a project
 */
async function getProjectPhases(projectId) {
  try {
    // Get phases for this project (using project_id column)
    const { data: phases } = await from('dev_project_phases')
      .select('id, phase_num, name, status')
      .eq('project_id', projectId)
      .order('phase_num', { ascending: true });

    if (!phases?.length) return [];

    // Get phase items for each phase
    const phasesWithItems = [];
    for (const phase of phases) {
      const { data: items } = await from('dev_phase_items')
        .select('id, title, status')
        .eq('phase_id', phase.id)
        .order('sort_order', { ascending: true });

      // Build keywords from phase name and items
      const keywords = new Set();
      extractTerms(phase.name).forEach(t => keywords.add(t));
      (items || []).forEach(item => {
        extractTerms(item.title).forEach(t => keywords.add(t));
      });

      phasesWithItems.push({
        ...phase,
        items: items || [],
        keywords: [...keywords]
      });
    }

    return phasesWithItems;
  } catch (err) {
    logger.error('getProjectPhases failed', { projectId, error: err.message });
    return [];
  }
}

/**
 * Find best phase match for an item
 * @returns {object|null} { phaseId, phaseName, score } or null if no good match
 */
function findBestPhase(itemTitle, phases, minScore = 0.2) {
  const itemTerms = extractTerms(itemTitle);

  if (itemTerms.length === 0) return null;

  let bestMatch = null;
  let bestScore = 0;

  for (const phase of phases) {
    if (phase.keywords.length === 0) continue;

    // Count matching keywords
    const matches = itemTerms.filter(t => phase.keywords.includes(t));
    const score = matches.length / itemTerms.length;

    if (score > bestScore && score >= minScore) {
      bestScore = score;
      bestMatch = {
        phaseId: phase.id,
        phaseName: phase.name,
        phaseNum: phase.phase_num,
        score,
        matchedTerms: matches
      };
    }
  }

  return bestMatch;
}

/**
 * Assign unassigned items to phases for a project
 * @param {string} table - Table name (dev_ai_todos, dev_ai_bugs)
 * @param {string} projectId - Project ID (can be parent or child)
 * @param {string} parentId - Parent project ID (where phases are defined)
 */
async function assignPhases(table, projectId, parentId) {
  try {
    // Get phases from the parent project
    const phases = await getProjectPhases(parentId);

    if (phases.length === 0) {
      return { assigned: 0, skipped: 0, noPhases: true };
    }

    // Get unassigned items (no phase_id)
    const { data: items } = await from(table)
      .select('id, title, status')
      .eq('project_id', projectId)
      .is('phase_id', null)
      .in('status', ['unassigned', 'open', 'pending', 'active']);

    if (!items?.length) {
      return { assigned: 0, skipped: 0 };
    }

    let assigned = 0;
    let skipped = 0;

    for (const item of items) {
      const match = findBestPhase(item.title, phases);

      if (match) {
        // Assign to phase and update status
        await from(table)
          .update({
            phase_id: match.phaseId,
            status: 'assigned',
            updated_at: new Date().toISOString()
          })
          .eq('id', item.id);

        assigned++;
        logger.info('Assigned item to phase', {
          table,
          itemId: item.id,
          title: item.title.substring(0, 50),
          phase: match.phaseName,
          score: match.score.toFixed(2)
        });
      } else {
        skipped++;
      }
    }

    return { assigned, skipped };
  } catch (err) {
    logger.error('assignPhases failed', { table, projectId, error: err.message });
    return { assigned: 0, skipped: 0, error: err.message };
  }
}

/**
 * Get parent project ID for a project
 * If the project IS a parent, return itself
 */
async function getParentId(projectId) {
  try {
    const { data } = await from('dev_projects')
      .select('id, parent_id, is_parent')
      .eq('id', projectId)
      .single();

    if (!data) return null;

    // If this is a parent project, return itself (phases are on parents)
    if (data.is_parent) return projectId;

    // Otherwise return its parent
    return data.parent_id;
  } catch (err) {
    return null;
  }
}

/**
 * Run phase assignment for all tables in a project
 */
async function assignAllPhases(projectId) {
  try {
    const parentId = await getParentId(projectId);

    if (!parentId) {
      return { todos: 0, bugs: 0, noParent: true };
    }

    const todosResult = await assignPhases('dev_ai_todos', projectId, parentId);
    const bugsResult = await assignPhases('dev_ai_bugs', projectId, parentId);

    return {
      todos: todosResult.assigned,
      bugs: bugsResult.assigned,
      skippedTodos: todosResult.skipped,
      skippedBugs: bugsResult.skipped,
      parentId
    };
  } catch (err) {
    logger.error('assignAllPhases failed', { projectId, error: err.message });
    return { todos: 0, bugs: 0, error: err.message };
  }
}

module.exports = {
  getProjectPhases,
  findBestPhase,
  assignPhases,
  assignAllPhases,
  getParentId,
  extractTerms
};
