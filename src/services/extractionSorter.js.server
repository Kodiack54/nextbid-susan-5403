/**
 * Extraction Sorter - Processes pending extractions from Chad/Jen
 * Sorts items into proper destination tables
 * Supports BOTH legacy category format AND new 20-bucket format
 */

const { from, query } = require('../lib/db');
const { Logger } = require('../lib/logger');
const projectDetector = require('./projectDetector');
const stripAnsi = require('../../shared/stripAnsi');

const logger = new Logger('Sorter');

// NEW 20-bucket format mapping
const BUCKET_TO_TABLE = {
  'Bugs Open': 'dev_ai_bugs',
  'Bugs Fixed': 'dev_ai_bugs',
  'Todos': 'dev_ai_todos',
  'Journal': 'dev_ai_journal',
  'Work Log': 'dev_ai_journal',
  'Ideas': 'dev_ai_knowledge',
  'Decisions': 'dev_ai_decisions',
  'Lessons': 'dev_ai_lessons',
  'System Breakdown': 'dev_ai_knowledge',
  'How-To Guide': 'dev_ai_docs',
  'Schematic': 'dev_ai_docs',
  'Reference': 'dev_ai_knowledge',
  'Naming Conventions': 'dev_ai_conventions',
  'File Structure': 'dev_ai_conventions',
  'Database Patterns': 'dev_ai_conventions',
  'API Patterns': 'dev_ai_conventions',
  'Component Patterns': 'dev_ai_conventions',
  'Quirks & Gotchas': 'dev_ai_knowledge',
  'Snippets': 'dev_ai_snippets',
  'Other': 'dev_ai_knowledge'
};

// Legacy category mapping
const CATEGORY_TO_TABLE = {
  todo: 'dev_ai_todos',
  bug: 'dev_ai_bugs',
  issue: 'dev_ai_bugs',
  knowledge: 'dev_ai_knowledge',
  solution: 'dev_ai_knowledge',
  config: 'dev_ai_knowledge',
  infrastructure: 'dev_ai_knowledge',
  decision: 'dev_ai_decisions',
  lesson: 'dev_ai_lessons',
  general: 'dev_ai_knowledge',
  discovery: 'dev_ai_knowledge'
};

// Garbage patterns to filter
const GARBAGE_PATTERNS = [
  /^\|/,                    // Starts with pipe (table output)
  /^\(\d+\)/,               // Starts with (8) etc
  /^- MMO/,                 // MMO task references
  /^be saved by/,           // Partial sentences
  /^GET\s+\/api/,           // API routes
  /\[.*m$/,                 // Ends with color code
  /^'\w+_ai/,               // Table name references
  /\\x1B/,                  // Escaped ANSI
  /\\u001b/i,               // Unicode ANSI
];

function isGarbage(text) {
  if (!text || text.length < 10) return true;
  if (text.length > 5000) return true;
  return GARBAGE_PATTERNS.some(p => p.test(text));
}

// Helper to get routing info from project path
async function getRoutingFromPath(projectPath) {
  if (!projectPath) return {};
  try {
    const { data: pathInfo } = await from('dev_project_paths')
      .select('project_id')
      .eq('path', projectPath)
      .limit(1);
    if (pathInfo?.[0]?.project_id) {
      const { data: proj } = await from('dev_projects')
        .select('client_id, platform_id, id')
        .eq('id', pathInfo[0].project_id)
        .single();
      if (proj) {
        return { client_id: proj.client_id, platform_id: proj.platform_id, project_id: proj.id };
      }
    }
  } catch (e) {
    logger.debug('Error getting routing', { error: e.message });
  }
  return {};
}

async function processPendingExtractions() {
  try {
    const { data: pending, error } = await from('dev_ai_smart_extractions')
      .select('*')
      .eq('status', 'pending')
      .order('created_at', { ascending: true })
      .limit(50);

    if (error) {
      logger.error('Error fetching pending extractions', { error: error.message });
      return { processed: 0, errors: 1 };
    }

    if (!pending || pending.length === 0) {
      return { processed: 0, errors: 0 };
    }

    logger.info(`[Sorter] Processing ${pending.length} pending extractions`);

    let processed = 0;
    let errors = 0;
    let skipped = 0;

    for (const extraction of pending) {
      try {
        const cleanContent = stripAnsi(extraction.content || '');
        
        if (isGarbage(cleanContent)) {
          await from('dev_ai_smart_extractions')
            .update({ status: 'skipped' })
            .eq('id', extraction.id);
          skipped++;
          continue;
        }

        extraction.content = cleanContent;
        const result = await sortExtraction(extraction);
        if (result.success) {
          processed++;
        } else {
          errors++;
        }
      } catch (err) {
        logger.error('Error processing extraction', { id: extraction.id, error: err.message });
        errors++;
      }
    }

    logger.info(`[Sorter] Processed ${processed}, skipped ${skipped}, errors ${errors}`);
    return { processed, errors, skipped };
  } catch (err) {
    logger.error('Error in processPendingExtractions', { error: err.message });
    return { processed: 0, errors: 1 };
  }
}

async function sortExtraction(extraction) {
  const { id, category, bucket, content, project_path, priority, metadata, session_id } = extraction;

  // NEW FORMAT: Use bucket field if present
  let targetTable;
  let usedBucket = bucket;
  
  if (bucket && BUCKET_TO_TABLE[bucket]) {
    targetTable = BUCKET_TO_TABLE[bucket];
    logger.debug('Using bucket format', { bucket, targetTable });
  } else {
    // LEGACY FORMAT: Use category field
    targetTable = CATEGORY_TO_TABLE[category] || 'dev_ai_knowledge';
    logger.debug('Using legacy category format', { category, targetTable });
  }

  let finalProjectPath = project_path;
  if (!finalProjectPath && content) {
    const detected = await projectDetector.detectProject(content);
    if (detected) {
      finalProjectPath = detected.server_path;
    }
  }

  try {
    // Route to appropriate insert function based on target table
    if (targetTable === 'dev_ai_todos') {
      await insertTodo(extraction, finalProjectPath);
    } else if (targetTable === 'dev_ai_bugs') {
      await insertBug(extraction, finalProjectPath, usedBucket);
    } else if (targetTable === 'dev_ai_knowledge') {
      await insertKnowledge(extraction, finalProjectPath, usedBucket);
    } else if (targetTable === 'dev_ai_decisions') {
      await insertDecision(extraction, finalProjectPath);
    } else if (targetTable === 'dev_ai_lessons') {
      await insertLesson(extraction, finalProjectPath);
    } else if (targetTable === 'dev_ai_journal') {
      await insertJournal(extraction, finalProjectPath, usedBucket);
    } else if (targetTable === 'dev_ai_docs') {
      await insertDoc(extraction, finalProjectPath, usedBucket);
    } else if (targetTable === 'dev_ai_conventions') {
      await insertConvention(extraction, finalProjectPath, usedBucket);
    } else if (targetTable === 'dev_ai_snippets') {
      await insertSnippet(extraction, finalProjectPath);
    } else {
      await insertKnowledge(extraction, finalProjectPath, usedBucket);
    }

    await from('dev_ai_smart_extractions')
      .update({ status: 'processed', processed_at: new Date().toISOString() })
      .eq('id', id);

    return { success: true };
  } catch (err) {
    logger.error('Error sorting extraction', { id, bucket, category, error: err.message });
    
    await from('dev_ai_smart_extractions')
      .update({ status: 'failed', metadata: { ...(metadata || {}), error: err.message } })
      .eq('id', id);

    return { success: false, error: err.message };
  }
}

// ============ INSERT FUNCTIONS ============

async function insertTodo(extraction, projectPath) {
  const { content, priority, session_id } = extraction;
  const title = content.substring(0, 200).split('\n')[0];
  const routing = await getRoutingFromPath(projectPath);
  
  await from('dev_ai_todos').insert({
    project_path: projectPath || '/var/www/Kodiack_Studio',
    title: title,
    description: content,
    priority: mapPriority(priority),
    status: 'pending',
    source_session_id: session_id,
    client_id: routing.client_id || null,
    project_id: routing.project_id || null
  });
}

async function insertBug(extraction, projectPath, bucket) {
  const { content, priority, session_id } = extraction;
  const title = content.substring(0, 200).split('\n')[0];
  const routing = await getRoutingFromPath(projectPath);
  
  // Determine status based on bucket
  const status = bucket === 'Bugs Fixed' ? 'fixed' : 'open';
  
  await from('dev_ai_bugs').insert({
    project_path: projectPath,
    title: title,
    description: content,
    severity: mapPriority(priority),
    status: status,
    source_session_id: session_id,
    client_id: routing.client_id || null,
    project_id: routing.project_id || null
  });
}

async function insertKnowledge(extraction, projectPath, bucket) {
  const { content, category, session_id } = extraction;
  const title = content.substring(0, 200).split('\n')[0];
  const routing = await getRoutingFromPath(projectPath);
  
  // Use bucket as subcategory if available
  const knowledgeCategory = bucket || category || 'general';
  
  await from('dev_ai_knowledge').insert({
    project_path: projectPath,
    title: title,
    content: content,
    category: knowledgeCategory,
    source_session_id: session_id,
    client_id: routing.client_id || null,
    project_id: routing.project_id || null
  });
}

async function insertDecision(extraction, projectPath) {
  const { content, session_id } = extraction;
  const title = content.substring(0, 200).split('\n')[0];
  const routing = await getRoutingFromPath(projectPath);
  
  await from('dev_ai_decisions').insert({
    project_path: projectPath,
    title: title,
    description: content,
    status: 'decided',
    source_session_id: session_id,
    client_id: routing.client_id || null,
    project_id: routing.project_id || null
  });
}

async function insertLesson(extraction, projectPath) {
  const { content, session_id } = extraction;
  const title = content.substring(0, 200).split('\n')[0];
  const routing = await getRoutingFromPath(projectPath);
  
  // Lessons are APPEND-ONLY - never override
  await from('dev_ai_lessons').insert({
    project_path: projectPath,
    title: title,
    content: content,
    source_session_id: session_id,
    client_id: routing.client_id || null,
    project_id: routing.project_id || null
  });
}

async function insertJournal(extraction, projectPath, bucket) {
  const { content, session_id } = extraction;
  const title = content.substring(0, 200).split('\n')[0];
  const routing = await getRoutingFromPath(projectPath);
  
  // Journal entries are APPEND-ONLY - never override
  const entryType = bucket === 'Work Log' ? 'work_log' : 'journal';
  
  await from('dev_ai_journal').insert({
    project_path: projectPath,
    title: title,
    content: content,
    entry_type: entryType,
    source_session_id: session_id,
    client_id: routing.client_id || null,
    project_id: routing.project_id || null
  });
}

async function insertDoc(extraction, projectPath, bucket) {
  const { content, session_id } = extraction;
  const title = content.substring(0, 200).split('\n')[0];
  const routing = await getRoutingFromPath(projectPath);
  
  const docType = bucket === 'How-To Guide' ? 'how_to' : 'schematic';
  
  await from('dev_ai_docs').insert({
    project_path: projectPath,
    title: title,
    content: content,
    doc_type: docType,
    source_session_id: session_id,
    client_id: routing.client_id || null,
    project_id: routing.project_id || null
  });
}

async function insertConvention(extraction, projectPath, bucket) {
  const { content, session_id } = extraction;
  const title = content.substring(0, 200).split('\n')[0];
  const routing = await getRoutingFromPath(projectPath);
  
  // Map bucket to convention type
  const conventionTypeMap = {
    'Naming Conventions': 'naming',
    'File Structure': 'file_structure',
    'Database Patterns': 'database',
    'API Patterns': 'api',
    'Component Patterns': 'component'
  };
  const conventionType = conventionTypeMap[bucket] || 'general';
  
  await from('dev_ai_conventions').insert({
    project_path: projectPath,
    title: title,
    content: content,
    convention_type: conventionType,
    source_session_id: session_id,
    client_id: routing.client_id || null,
    project_id: routing.project_id || null
  });
}

async function insertSnippet(extraction, projectPath) {
  const { content, session_id } = extraction;
  const title = content.substring(0, 200).split('\n')[0];
  const routing = await getRoutingFromPath(projectPath);
  
  await from('dev_ai_snippets').insert({
    project_path: projectPath,
    title: title,
    code: content,
    source_session_id: session_id,
    client_id: routing.client_id || null,
    project_id: routing.project_id || null
  });
}

// ============ HELPERS ============

function mapPriority(priority) {
  const map = { low: 'low', normal: 'medium', high: 'high', critical: 'critical' };
  return map[priority] || 'medium';
}

// ============ SORTER LIFECYCLE ============

let sortInterval = null;

function startSorter() {
  if (sortInterval) return;
  
  logger.info('[Sorter] Starting extraction sorter (30s interval)');
  processPendingExtractions();
  sortInterval = setInterval(processPendingExtractions, 30000);
}

function stopSorter() {
  if (sortInterval) {
    clearInterval(sortInterval);
    sortInterval = null;
    logger.info('[Sorter] Stopped extraction sorter');
  }
}

module.exports = {
  processPendingExtractions,
  sortExtraction,
  startSorter,
  stopSorter,
  BUCKET_TO_TABLE,
  CATEGORY_TO_TABLE
};
